<?xml version="1.0" ?><occamDoc><declaration name="servo" type="module"><name>servo</name><description><para>Servo wrapper functions.</para></description><summary>Servo wrapper functions</summary><children><declaration name="SERVO" type="protocol"><name>SERVO</name><filename>servo.module</filename><lineNumber>27</lineNumber><description><para>Servo control protocol.</para></description><summary>Servo control protocol</summary><definition>PROTOCOL SERVO</definition><children><declaration name="max" type="tag"><name>max</name><filename>servo.module</filename><lineNumber>31</lineNumber><description><para>Maximum time active; in microseconds.</para></description><summary>Maximum time active; in microseconds</summary><items><item name="max"/><definition>INT</definition><description><para>Initially 2300. must be less than <code>frequency</code>.</para></description></items><definition>max ; INT</definition></declaration><declaration name="min" type="tag"><name>min</name><filename>servo.module</filename><lineNumber>34</lineNumber><description><para>Minimum time active; in microseconds.</para></description><summary>Minimum time active; in microseconds</summary><items><item name="min"/><definition>INT</definition><description><para>Initially 700. must be more than 0.</para></description></items><definition>min ; INT</definition></declaration><declaration name="div" type="tag"><name>div</name><filename>servo.module</filename><lineNumber>37</lineNumber><description><para>Number of divisions in the span between <code>max</code> - <code>min.</code></para></description><summary>Number of divisions in the span between  max  -  min</summary><items><item name="div"/><definition>INT</definition><description><para>Initially 180. Must be &lt;= <code>max</code> - <code>min</code>.</para></description></items><definition>div ; INT</definition></declaration><declaration name="pos" type="tag"><name>pos</name><filename>servo.module</filename><lineNumber>40</lineNumber><description><para>Positition of the servo; <em>This is what you will be using the most</em>.</para></description><summary>Positition of the servo;  This is what you will be using the most </summary><items><item name="pos"/><definition>INT</definition><description><para>Initially 90. Must be between 0:<code>pos</code>.</para></description></items><definition>pos ; INT</definition></declaration><declaration name="usec" type="tag"><name>usec</name><filename>servo.module</filename><lineNumber>47</lineNumber><description><para>Number of microseconds (greater than <code>min</code>) the pulse to the servo will last.</para><para> <em>We strongly recommend using [@code div] and [@code pos] to
 effect the position of the servo</em>.</para></description><summary>Number of microseconds (greater than  min ) the pulse to the servo will last</summary><items><item name="usec"/><definition>INT</definition><description><para>Automatically calculated when <code>pos</code> is reset.</para></description></items><definition>usec ; INT</definition></declaration><declaration name="frequency" type="tag"><name>frequency</name><filename>servo.module</filename><lineNumber>53</lineNumber><description><para>Frequency of the servo pulse.</para><para> <em>Do not change this casually.</em> Most servos require a pulse once every 20 milliseconds, which is what <code>frequency</code> defaults to.</para></description><summary>Frequency of the servo pulse</summary><items><item name="frequency"/><definition>INT</definition><description><para>Initially 20000. Measured in microseconds.</para></description></items><definition>frequency ; INT</definition></declaration><declaration name="start" type="tag"><name>start</name><filename>servo.module</filename><lineNumber>59</lineNumber><description><para>Starts servo operations.</para><para> We recommened setting <code>div</code> and <code>pos</code> before sending the <code>start</code> signal, and not changing <code>div</code> after.</para></description><summary>Starts servo operations</summary><definition>start</definition></declaration><declaration name="stop" type="tag"><name>stop</name><filename>servo.module</filename><lineNumber>62</lineNumber><description><para>Supposed to stop servo operations. We've not added that functionality yet.</para></description><summary>Supposed to stop servo operations</summary><definition>stop</definition></declaration></children></declaration><declaration name="servo" type="proc"><name>servo</name><filename>servo.module</filename><lineNumber>75</lineNumber><description><para>General servo control. Pass a PWM pin and SERVO channel into this process, and all signals sent over the channel will be acted upon properly.</para></description><summary>General servo control</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be used for servo operations. For the time being, only PWM pins connected to a 16 bit timer can be used to operate servos.</para></description></params><params><item name="s"/><definition>CHAN SERVO</definition><description><para>The servo channel used for controlling servo operations.</para></description></params><definition>PROC servo (VAL INT board.pin, CHAN SERVO s?)</definition></declaration><declaration name="simple.servo" type="proc"><name>simple.servo</name><filename>servo.module</filename><lineNumber>151</lineNumber><description><para>Stepping-stone servo control process. The idea is this is a simpler process to work with servos than the PROTOCOL. You need to know your servo's bounds for this one, but it does allow for a single-channel servo control.</para></description><summary>Stepping-stone servo control process</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be used for servo operations. For the time being, only PWM pins connected to a 16 bit timer can be used to operate servos.</para></description></params><params><item name="p"/><definition>CHAN BYTE</definition><description><para>The input BYTE channel for setting the position of the servo. <em>This is hard-coded to be a range from 0 to 180. Do not attempt to
   send anything outside of that range.</em></para></description></params><definition>PROC simple.servo (VAL INT board.pin, CHAN BYTE p?)</definition></declaration></children></declaration><declaration name="twi" type="module"><name>twi</name><description><para>occam implementation of TWI for the AVR</para></description><summary>occam implementation of TWI for the AVR</summary></declaration><declaration name="wiring" type="module"><name>wiring</name><description><para>Occam bindings written to resemble the C-like wiring API</para></description><summary>Occam bindings written to resemble the C-like wiring API</summary></declaration><declaration name="printing" type="module"><name>printing</name><description><para>Printing support for Plumbing</para></description><summary>Printing support for Plumbing</summary><children><declaration name="serial.setup" type="proc"><name>serial.setup</name><filename>printing.module</filename><lineNumber>43</lineNumber><description><para>Begins serial operations on the given board pin.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc. In the case of this process, RX0 and TX0 will both signal the activation of serial port 0, as RX1 and TX1 will activate port 1, etc. the 'R' and 'T' can be used interchangeably.</para></description><summary>Begins serial operations on the given board pin</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to being serial operations on.</para></description></params><params><item name="baud"/><definition>VAL INT32</definition><description><para>The baud rate at which to transmit serial data.</para></description></params><definition>PROC serial.setup (VAL INT board.pin, VAL INT32 baud)</definition></declaration><declaration name="serial.read.byte" type="proc"><name>serial.read.byte</name><filename>printing.module</filename><lineNumber>56</lineNumber><description><para>Reads a BYTE from the given pin.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc.</para></description><summary>Reads a BYTE from the given pin</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The pin from which to read.</para></description></params><params><item name="b"/><definition>RESULT BYTE</definition><description><para>The resulting byte from the read.</para></description></params><definition>PROC serial.read.byte (VAL INT board.pin, RESULT BYTE b)</definition></declaration><declaration name="serial.write.byte" type="proc"><name>serial.write.byte</name><filename>printing.module</filename><lineNumber>69</lineNumber><description><para>Write a BYTE to the given pin.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc.</para></description><summary>Write a BYTE to the given pin</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be written to.</para></description></params><params><item name="b"/><definition>VAL BYTE</definition><description><para>The BYTE to be written.</para></description></params><definition>PROC serial.write.byte (VAL INT board.pin, VAL BYTE b)</definition></declaration><declaration name="serial.write.int" type="proc"><name>serial.write.int</name><filename>printing.module</filename><lineNumber>82</lineNumber><description><para>Write an INT to the serial port in hex.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc.</para></description><summary>Write an INT to the serial port in hex</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be written to.</para></description></params><params><item name="n"/><definition>VAL INT</definition><description><para>The INT to write.</para></description></params><definition>PROC serial.write.int (VAL INT board.pin, VAL INT n)</definition></declaration><declaration name="serial.write.int32" type="proc"><name>serial.write.int32</name><filename>printing.module</filename><lineNumber>97</lineNumber><description><para>Write an INT32 to the serial port in hex.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc.</para></description><summary>Write an INT32 to the serial port in hex</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be written to.</para></description></params><params><item name="n"/><definition>VAL INT32</definition><description><para>The long integer (INT32) to write.</para></description></params><definition>PROC serial.write.int32 (VAL INT board.pin, VAL INT32 n)</definition></declaration><declaration name="serial.write.string" type="proc"><name>serial.write.string</name><filename>printing.module</filename><lineNumber>112</lineNumber><description><para>Write a string to the serial port.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc.</para></description><summary>Write a string to the serial port</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be written to.</para></description></params><params><item name="string"/><definition>VAL []BYTE</definition><description><para>The array of BYTEs to write.</para></description></params><definition>PROC serial.write.string (VAL INT board.pin, VAL []BYTE string)</definition></declaration><declaration name="serial.write.newline" type="proc"><name>serial.write.newline</name><filename>printing.module</filename><lineNumber>125</lineNumber><description><para>Write a newline.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc.</para></description><summary>Write a newline</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be written to.</para></description></params><definition>PROC serial.write.newline (VAL INT board.pin)</definition></declaration><declaration name="printing.zeroArray" type="proc"><name>printing.zeroArray</name><filename>printing.module</filename><lineNumber>135</lineNumber><description><para>Fills the passed array with the <em>character</em> '0'.</para></description><summary>Fills the passed array with the  character  '0'</summary><params><item name="arr"/><definition>[]BYTE</definition><description><para>The array to be filled with '0's.</para></description></params><definition>PROC printing.zeroArray([]BYTE arr)</definition></declaration><declaration name="printing.trimTrailing0s" type="proc"><name>printing.trimTrailing0s</name><filename>printing.module</filename><lineNumber>147</lineNumber><description><para>Helps the user trim the trailing 0s from an array of BYTEs by decrementing <code>total</code> by one for every consecutive '0' at the end of the BYTE array.</para></description><summary>Helps the user trim the trailing 0s from an array of BYTEs by decrementing  total  by one for every consecutive '0' at the end of the BYTE array</summary><params><item name="arr"/><definition>VAL []BYTE</definition><description><para>The array of BYTEs to be processed.</para></description></params><params><item name="total"/><definition>INT</definition><description><para>On completion of the PROC, this will be the number of elements of the array useful to printing.</para></description></params><definition>PROC printing.trimTrailing0s (VAL []BYTE arr, INT total)</definition></declaration><declaration name="printing.real32toa.helper" type="proc"><name>printing.real32toa.helper</name><filename>printing.module</filename><lineNumber>163</lineNumber><description><para>Real 32 to array helper function.</para><para> Honestly, this is magic to me. You probably don't need to invoke this.</para></description><summary>Real 32 to array helper function</summary><params><item name="lhs"/><definition>VAL INT</definition></params><params><item name="arr"/><definition>[]BYTE</definition></params><params><item name="length"/><definition>INT</definition></params><definition>PROC printing.real32toa.helper (VAL INT lhs, []BYTE arr, INT length)</definition></declaration><declaration name="real32toa" type="proc"><name>real32toa</name><filename>printing.module</filename><lineNumber>204</lineNumber><description><para>Converts <code>n</code> into a printable array. The BYTE array <code>arr</code> and the INT <code>total</code> should be passed to this process blank, as <code>arr</code> will be populated with printable characters, and <code>total</code> will suggest the number of useful elements to write.</para></description><summary>Converts  n  into a printable array</summary><params><item name="n"/><definition>VAL REAL32</definition><description><para>The REAL32 to be printed.</para></description></params><params><item name="arr"/><definition>[]BYTE</definition><description><para>The <em>initially empty</em> array to be used for storing BYTEs for printing.</para></description></params><params><item name="total"/><definition>INT</definition><description><para>The <em>initially zero</em> INT that will store the total number of elements of <code>arr</code> useful for printing.</para></description></params><definition>PROC real32toa (VAL REAL32 n, []BYTE arr, INT total)</definition></declaration><declaration name="serial.write.real32" type="proc"><name>serial.write.real32</name><filename>printing.module</filename><lineNumber>272</lineNumber><description><para>Write a REAL32 to the serial port in decimal form.</para><para> <code>board.pin</code> <em>must</em> be written as TX0, RX0, TX1, RX1, etc.</para></description><summary>Write a REAL32 to the serial port in decimal form</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be written to.</para></description></params><params><item name="n"/><definition>VAL REAL32</definition><description><para>The code REAL32 to write.</para></description></params><params><item name="precision"/><definition>VAL INT</definition><description><para>The maximum length of the printed number.</para></description></params><definition>PROC serial.write.real32 (VAL INT board.pin, VAL REAL32 n, VAL INT precision)</definition></declaration></children></declaration><declaration name="base" type="module"><name>base</name><description><para>Very basic, nothing-specific code that is called at every level of code.</para></description><summary>Very basic, nothing-specific code that is called at every level of code</summary><children><declaration name="die" type="proc"><name>die</name><filename>base.module</filename><lineNumber>31</lineNumber><description><para>Kills everything and reports an error back to the user.</para></description><summary>Kills everything and reports an error back to the user</summary><params><item name="error"/><definition>VAL []BYTE</definition><description><para>A string containing the error message.</para></description></params><definition>INLINE PROC die (VAL []BYTE error)</definition></declaration><declaration name="BV" type="function"><name>BV</name><filename>base.module</filename><lineNumber>47</lineNumber><description><para>Convert a bit number to a bit value. This is just <code>1 &lt;&lt; bit</code>, like <text>_BV</text> in the C headers.</para></description><summary>Convert a bit number to a bit value</summary><params><item name="bit"/><definition>VAL INT</definition><description><para>How far to shift 1 left.</para></description></params><returns><item/><definition>BYTE</definition><description><para>1 shifted <code>bit</code> to the left</para></description></returns><definition>BYTE INLINE FUNCTION BV (VAL INT bit)</definition></declaration><declaration name="delay" type="proc"><name>delay</name><filename>base.module</filename><lineNumber>54</lineNumber><description><para>Wait for a period of time.</para></description><summary>Wait for a period of time</summary><params><item name="millis"/><definition>VAL INT</definition><description><para>Time to wait, in milliseconds</para></description></params><definition>PROC delay (VAL INT millis)</definition></declaration></children></declaration><declaration name="digital" type="module"><name>digital</name><description><para>Processes for manipulating digital pins.</para></description><summary>Processes for manipulating digital pins</summary><children><declaration name="LEVEL" type="datatype"><name>LEVEL</name><filename>digital.module</filename><lineNumber>32</lineNumber><description><para>Symbolic constant for setting the level of a digital pin.</para><para> Can be </para><list><listitem> <code>VAL LEVEL HIGH</code> or </listitem><listitem> <code>VAL LEVEL LOW</code></listitem></list></description><summary>Symbolic constant for setting the level of a digital pin</summary><definition>DATA TYPE LEVEL</definition></declaration><declaration name="INPUT" type="constant"><name>INPUT</name><filename>digital.module</filename><lineNumber>63</lineNumber><description><para>Symbolic constant for setting data direction registers to input.</para></description><summary>Symbolic constant for setting data direction registers to input</summary><definition>VAL INT INPUT</definition></declaration><declaration name="OUTPUT" type="constant"><name>OUTPUT</name><filename>digital.module</filename><lineNumber>65</lineNumber><description><para>Symbolic constant for setting data direction registers to output.</para></description><summary>Symbolic constant for setting data direction registers to output</summary><definition>VAL INT OUTPUT</definition></declaration><declaration name="digital.write" type="proc"><name>digital.write</name><filename>digital.module</filename><lineNumber>72</lineNumber><description><para>Sets the digital state of a pin to either HIGH or LOW.</para></description><summary>Sets the digital state of a pin to either HIGH or LOW</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be set.</para></description></params><params><item name="state"/><definition>VAL LEVEL</definition><description><para>The state to set -- Either HIGH or LOW.</para></description></params><definition>PROC digital.write (VAL INT board.pin, VAL LEVEL state)</definition></declaration><declaration name="digital.read" type="proc"><name>digital.read</name><filename>digital.module</filename><lineNumber>88</lineNumber><description><para>Reads the digital state of a pin. Either HIGH or LOW.</para></description><summary>Reads the digital state of a pin</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to be read.</para></description></params><params><item name="state"/><definition>RESULT LEVEL</definition><description><para>The pin's current state -- Either HIGH or LOW.</para></description></params><definition>PROC digital.read (VAL INT board.pin, RESULT LEVEL state)</definition></declaration><declaration name="digital.mode" type="proc"><name>digital.mode</name><filename>digital.module</filename><lineNumber>106</lineNumber><description><para>Sets the Data Direction Register of the given pin (sets the flow of data) to either INPUT or OUTPUT.</para></description><summary>Sets the Data Direction Register of the given pin (sets the flow of data) to either INPUT or OUTPUT</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The board pin to set the direction of.</para></description></params><params><item name="mode"/><definition>VAL INT</definition><description><para>The mode to be set. Either INPUT or OUTPUT.</para></description></params><definition>PROC digital.mode (VAL INT board.pin, mode)</definition></declaration><declaration name="digital.output" type="proc"><name>digital.output</name><filename>digital.module</filename><lineNumber>124</lineNumber><description><para>Set digital levels on a pin. Reads LEVEL values (LOW or HIGH) on the input channel, and sets the value of the specified pin accordingly.</para></description><summary>Set digital levels on a pin</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The Arduino pin number</para></description></params><params><item name="in"/><definition>CHAN LEVEL</definition><description><para>Pin levels (LOW or HIGH)</para></description></params><definition>PROC digital.output (VAL INT board.pin, CHAN LEVEL in?)</definition></declaration><declaration name="digital.input" type="proc"><name>digital.input</name><filename>digital.module</filename><lineNumber>143</lineNumber><description><para>Read digital levels on external level interrupt pins. This procedure will output a LEVEL (either LOW or HIGH) whenever the pin changes value.</para></description><summary>Read digital levels on external level interrupt pins</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The pin number (pins 2 and 3 are safe choices).</para></description></params><params><item name="out"/><definition>CHAN LEVEL</definition><description><para>The LEVEL, output when the pin changes level.</para></description></params><definition>PROC digital.input (VAL INT board.pin, CHAN LEVEL out!)</definition></declaration></children></declaration><declaration name="plumbing" type="module"><name>plumbing</name><description><para>The Plumbing library.</para><para> <code>PROC</code>s in this module generally have arguments in this order:</para><list><listitem> non-channels; </listitem><listitem> input channels; </listitem><listitem> output channels.</listitem></list></description><summary>The Plumbing library</summary><children><declaration name="debounce" type="proc"><name>debounce</name><filename>plumbing.module</filename><lineNumber>65</lineNumber><description><para>Debounce a channel. Debounces a channel of LEVELs. Specifically, if multiple values come in within the DEBOUNCE.TIME (currently 50ms), only the first value is passed through.</para></description><summary>Debounce a channel</summary><params><item name="in"/><definition>CHAN LEVEL</definition><description><para>The incoming LEVEL values</para></description></params><params><item name="out"/><definition>CHAN LEVEL</definition><description><para>The outgoing LEVEL values, debounced</para></description></params><definition>PROC debounce (CHAN LEVEL in?, out!)</definition></declaration><declaration name="level.to.signal" type="proc"><name>level.to.signal</name><filename>plumbing.module</filename><lineNumber>94</lineNumber><description><para>Convert a LEVEL to a SIGNAL. Consumes a stream of LEVEL values, and emits a SIGNAL for each LEVEL received, regardless of whether it is LOW or HIGH.</para></description><summary>Convert a LEVEL to a SIGNAL</summary><params><item name="in"/><definition>CHAN LEVEL</definition><description><para>Input LEVEL values.</para></description></params><params><item name="out"/><definition>CHAN SIGNAL</definition><description><para>Output SIGNALs.</para></description></params><definition>PROC level.to.signal (CHAN LEVEL in?, CHAN SIGNAL out!)</definition></declaration><declaration name="invert.level" type="proc"><name>invert.level</name><filename>plumbing.module</filename><lineNumber>110</lineNumber><description><para>Invert LEVELs. Reads in LEVEL values, and outputs the opposite. Upon receiving a LOW, sends a HIGH, and visa versa.</para></description><summary>Invert LEVELs</summary><params><item name="in"/><definition>CHAN LEVEL</definition><description><para>Incoming LEVEL values.</para></description></params><params><item name="out"/><definition>CHAN LEVEL</definition><description><para>Outgoing LEVEL values, inverted.</para></description></params><definition>PROC invert.level (CHAN LEVEL in?, out!)</definition></declaration><declaration name="tick" type="proc"><name>tick</name><filename>plumbing.module</filename><lineNumber>125</lineNumber><description><para>Generates a consistent stream of SIGNALs. Every <code>period</code> milliseconds, a SIGNAL is generated.</para></description><summary>Generates a consistent stream of SIGNALs</summary><params><item name="period"/><definition>VAL INT</definition><description><para>A delay time in milliseconds.</para></description></params><params><item name="out"/><definition>CHAN SIGNAL</definition><description><para>SIGNALs generated after the given delay.</para></description></params><definition>PROC tick (VAL INT period, CHAN SIGNAL out!)</definition></declaration><declaration name="toggle" type="proc"><name>toggle</name><filename>plumbing.module</filename><lineNumber>142</lineNumber><description><para>Outputs an alternating stream of LEVEL values. Starting with an initial level (either LOW or HIGH), this process outputs a stream of alternating LEVEL values upon request. On receiving a SIGNAL, the next LEVEL is emitted</para></description><summary>Outputs an alternating stream of LEVEL values</summary><params><item name="initial.level"/><definition>VAL LEVEL</definition><description><para>Either LOW or HIGH to start.</para></description></params><params><item name="in"/><definition>CHAN SIGNAL</definition><description><para>The request line.</para></description></params><params><item name="out"/><definition>CHAN LEVEL</definition><description><para>The alternating stream of LEVEL values.</para></description></params><definition>PROC toggle (VAL LEVEL initial.level, CHAN SIGNAL in?, CHAN LEVEL out!)</definition></declaration><declaration name="pin.toggle" type="proc"><name>pin.toggle</name><filename>plumbing.module</filename><lineNumber>159</lineNumber><description><para>Drives a pin alternately LOW and HIGH. Upon request, alternates the level of a pin from LOW to HIGH.</para></description><summary>Drives a pin alternately LOW and HIGH</summary><params><item name="pin"/><definition>VAL INT</definition><description><para>The (digital) Arduino pin we want to drive.</para></description></params><params><item name="initial.level"/><definition>VAL LEVEL</definition><description><para>Either LOW or HIGH.</para></description></params><params><item name="in"/><definition>CHAN SIGNAL</definition><description><para>The request line.</para></description></params><definition>PROC pin.toggle (VAL INT pin, VAL LEVEL initial.level, CHAN SIGNAL in?)</definition></declaration><declaration name="blink" type="proc"><name>blink</name><filename>plumbing.module</filename><lineNumber>173</lineNumber><description><para>Drives a pin alternately LOW and HIGH on a fixed cycle. Every <code>delay.time</code> milliseconds, toggles a pin.</para></description><summary>Drives a pin alternately LOW and HIGH on a fixed cycle</summary><params><item name="pin"/><definition>VAL INT</definition><description><para>The Arduino pin.</para></description></params><params><item name="delay.time"/><definition>VAL INT</definition><description><para>The number of milliseconds between toggles.</para></description></params><definition>PROC blink (VAL INT pin, delay.time)</definition></declaration><declaration name="heartbeat" type="proc"><name>heartbeat</name><filename>plumbing.module</filename><lineNumber>198</lineNumber><description><para>A parallel health monitor.</para></description><summary>A parallel health monitor</summary><definition>PROC heartbeat ()</definition></declaration><declaration name="adc" type="proc"><name>adc</name><filename>plumbing.module</filename><lineNumber>223</lineNumber><description><para>Reads the analog value of a given pin. Upon request, performs an analog to digital conversion, comparing the voltage at <code>analog.pin</code> with the specified reference voltage. No matter which reference is used, the value of <code>out</code> will always rest between 0 and 1023.</para><para> There is a safeguard put in place that should allow <code>analog.pin</code> to be properly read if written as 0, 1, 2, etc., but it is still recommended that one writes A0, A1, etc. to avoid confusion.</para></description><summary>Reads the analog value of a given pin</summary><params><item name="analog.pin"/><definition>VAL INT</definition><description><para>The Analog pin number. (A0, A1, A2)</para></description></params><params><item name="ref"/><definition>VAL INT</definition><description><para>The source of the reference voltage. Either VCC (default), AREF (external), or INTERNAL (1.1v internal reference).</para></description></params><params><item name="in"/><definition>CHAN SIGNAL</definition><description><para>The request line.</para></description></params><params><item name="out"/><definition>CHAN INT</definition><description><para>The output channel for converted readings. 0 - 1023.</para></description></params><definition>PROC adc (VAL INT analog.pin, VAL INT ref, CHAN SIGNAL in?, CHAN INT out!)</definition></declaration><declaration name="potentiometer.byte" type="proc"><name>potentiometer.byte</name><filename>plumbing.module</filename><lineNumber>248</lineNumber><description><para>Reads from a potentiometer and maps the incoming value to a BYTE. Upon request, the incoming value from a potentiometer (a knob, slider...) connected to <code>analog.pin</code> to will be mapped to an appropriate value between 0-255.</para><para> There is a safeguard put in place that should allow <code>analog.pin</code> to be properly read if written as 0, 1, 2, etc., but it is still recommended that one writes A0, A1, etc. to avoid confusion.</para></description><summary>Reads from a potentiometer and maps the incoming value to a BYTE</summary><params><item name="analog.pin"/><definition>VAL INT</definition><description><para>The analog pin the potentiometer is connected to.</para></description></params><params><item name="in"/><definition>CHAN SIGNAL</definition><description><para>The request line.</para></description></params><params><item name="out"/><definition>CHAN BYTE</definition><description><para>The output chanel for mapped values. 0-255.</para></description></params><definition>PROC potentiometer.byte (VAL INT analog.pin, CHAN SIGNAL in?, CHAN BYTE out!)</definition></declaration><declaration name="clamp.byte" type="proc"><name>clamp.byte</name><filename>plumbing.module</filename><lineNumber>272</lineNumber><description><para>Limits the range of values in a stream. Takes <code>low</code> and <code>high</code> as limits, and any BYTEs read in that are below <code>low</code> are clamped to <code>low</code>, and likewise with the <code>high</code> value.</para></description><summary>Limits the range of values in a stream</summary><params><item name="low"/><definition>VAL BYTE</definition><description><para>The lower limit for valid numbers.</para></description></params><params><item name="high"/><definition>VAL BYTE</definition><description><para>The upper limit for valid numbers.</para></description></params><params><item name="in"/><definition>CHAN BYTE</definition><description><para>The input stream of BYTEs.</para></description></params><params><item name="out"/><definition>CHAN BYTE</definition><description><para>The output stream of BYTEs.</para></description></params><definition>PROC clamp.byte (VAL BYTE low, high, CHAN BYTE in?, out!)</definition></declaration><declaration name="clamp.int" type="proc"><name>clamp.int</name><filename>plumbing.module</filename><lineNumber>296</lineNumber><description><para>Limits the range of values in a stream. Takes <code>low</code> and <code>high</code> as limits, and any INTs read in that are below <code>low</code> are clamped to <code>low</code>, and likewise with the <code>high</code> value.</para></description><summary>Limits the range of values in a stream</summary><params><item name="low"/><definition>VAL INT</definition><description><para>The lower limit for valid numbers.</para></description></params><params><item name="high"/><definition>VAL INT</definition><description><para>The upper limit for valid numbers.</para></description></params><params><item name="in"/><definition>CHAN INT</definition><description><para>The input stream of INTs.</para></description></params><params><item name="out"/><definition>CHAN INT</definition><description><para>The output stream of INTs.</para></description></params><definition>PROC clamp.int (VAL INT low, high, CHAN INT in?, out!)</definition></declaration><declaration name="crawl.byte" type="proc"><name>crawl.byte</name><filename>plumbing.module</filename><lineNumber>323</lineNumber><description><para>Crawls a BYTE from 0 to <code>high</code> and back down (and back up, etc.). Pausing <code>wait</code> milliseconds between each signal send, and incrementing (in either direction) <code>step</code> between each send, the outgoing value is capped at 0 and <code>high</code>.</para></description><summary>Crawls a BYTE from 0 to  high  and back down (and back up, etc.)</summary><params><item name="high"/><definition>VAL BYTE</definition><description><para>The upper limit of output values.</para></description></params><params><item name="step"/><definition>VAL BYTE</definition><description><para>The increment between each send.</para></description></params><params><item name="wait"/><definition>VAL INT</definition><description><para>The time - in milliseconds - to wait after a successful send before attempting another.</para></description></params><params><item name="out"/><definition>CHAN BYTE</definition><description><para>The output stream of BYTEs.</para></description></params><definition>PROC crawl.byte (VAL BYTE high, step, VAL INT wait, CHAN BYTE out!)</definition></declaration><declaration name="crawl.int" type="proc"><name>crawl.int</name><filename>plumbing.module</filename><lineNumber>368</lineNumber><description><para>Crawls an INT from 0 to <code>high</code> and back down (and back up, etc.). Pausing <code>wait</code> milliseconds between each signal send, and incrementing (in either direction) <code>step</code> between each send, the outgoing value is capped at 0 and <code>high</code>.</para></description><summary>Crawls an INT from 0 to  high  and back down (and back up, etc.)</summary><params><item name="high"/><definition>VAL INT</definition><description><para>The upper limit of output values.</para></description></params><params><item name="step"/><definition>VAL INT</definition><description><para>The increment between each send.</para></description></params><params><item name="wait"/><definition>VAL INT</definition><description><para>The time - in milliseconds - to wait after a successful send before attempting another.</para></description></params><params><item name="out"/><definition>CHAN INT</definition><description><para>The output stream of INTs.</para></description></params><definition>PROC crawl.int (VAL INT high, step, VAL INT wait, CHAN INT out!)</definition></declaration><declaration name="pwm" type="proc"><name>pwm</name><filename>plumbing.module</filename><lineNumber>412</lineNumber><description><para>Writes an analog value to a pin. For a given (PWM) pin, sets the observed analog level to a value between 0 and 255. Negative values are treated as 0, and values greater than 255 are treated as 255.</para></description><summary>Writes an analog value to a pin</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The pin number.</para></description></params><params><item name="level"/><definition>CHAN BYTE</definition><description><para>The input level channel.</para></description></params><definition>PROC pwm (VAL INT board.pin, CHAN BYTE level?)</definition></declaration><declaration name="pwm16" type="proc"><name>pwm16</name><filename>plumbing.module</filename><lineNumber>435</lineNumber><description><para>Writes an analog value to a pin. For a given (PWM) pin, sets the level to a value between 0 and <code>top</code>. Negative values are treated as 0, and values greater than <code>top</code> are treated as [code top].</para><para> <em>Be careful</em>. Not every PWM pin is connected to a 16 bit timer, so not every pin labeled as a PWM can be used with this PROC.</para></description><summary>Writes an analog value to a pin</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The Arduino pin number</para></description></params><params><item name="top"/><definition>VAL INT</definition><description><para>The highest level top can be set to.</para></description></params><params><item name="level"/><definition>CHAN INT</definition><description><para>The input level channel.</para></description></params><definition>PROC pwm16 (VAL INT board.pin, VAL INT top, CHAN INT level?)</definition></declaration><declaration name="button.press" type="proc"><name>button.press</name><filename>plumbing.module</filename><lineNumber>460</lineNumber><description><para>Watches for button presses on external level interrupt pins. When a button is pressed a SIGNAL is generated. Uses digital.input, debounce, and level.to.signal.</para></description><summary>Watches for button presses on external level interrupt pins</summary><params><item name="board.pin"/><definition>VAL INT</definition><description><para>The pin the button is connected to (pins 2 and 3 are safe bets).</para></description></params><params><item name="out"/><definition>CHAN SIGNAL</definition><description><para>SIGNALs generated when the button is pressed.</para></description></params><definition>PROC button.press (VAL INT board.pin, CHAN SIGNAL out!)</definition></declaration></children></declaration><declaration name="pwm" type="module"><name>pwm</name></declaration></occamDoc>